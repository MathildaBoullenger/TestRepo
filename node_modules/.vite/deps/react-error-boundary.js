"use client";
import {
  __toESM,
  require_react
} from "./chunk-OMFGQDFA.js";

// node_modules/react-error-boundary/dist/react-error-boundary.esm.js
var import_react = __toESM(require_react());
var ErrorBoundaryContext = (0, import_react.createContext)(null);
var initialState = {
  didCatch: false,
  error: null
};
var ErrorBoundary = class extends import_react.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: true,
      error
    };
  }
  resetErrorBoundary(...args) {
    var _a, _b;
    const {
      error
    } = this.state;
    if (error !== null) {
      (_b = (_a = this.props).onReset) == null ? void 0 : _b.call(_a, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _a, _b;
    (_b = (_a = this.props).onError) == null ? void 0 : _b.call(_a, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    var _a, _b;
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      (_b = (_a = this.props).onReset) == null ? void 0 : _b.call(_a, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if ((0, import_react.isValidElement)(fallback)) {
        childToRender = fallback;
      } else if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = (0, import_react.createElement)(FallbackComponent, props);
      } else {
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
    }
    return (0, import_react.createElement)(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
};
function hasArrayChanged(a = [], b = []) {
  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));
}
function assertErrorBoundaryContext(value) {
  if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") {
    throw new Error("ErrorBoundaryContext not found");
  }
  return true;
}
function useErrorBoundary() {
  const context = (0, import_react.useContext)(ErrorBoundaryContext);
  assertErrorBoundaryContext(context);
  const [state, setState] = (0, import_react.useState)({
    error: null,
    hasError: false
  });
  const memoized = (0, import_react.useMemo)(() => ({
    resetBoundary: () => {
      context == null ? void 0 : context.resetErrorBoundary();
      setState({
        error: null,
        hasError: false
      });
    },
    showBoundary: (error) => setState({
      error,
      hasError: true
    })
  }), [context == null ? void 0 : context.resetErrorBoundary]);
  if (state.hasError) {
    throw state.error;
  }
  return memoized;
}
function withErrorBoundary(component, errorBoundaryProps) {
  const Wrapped = (0, import_react.forwardRef)((props, ref) => (0, import_react.createElement)(ErrorBoundary, errorBoundaryProps, (0, import_react.createElement)(component, {
    ...props,
    ref
  })));
  const name = component.displayName || component.name || "Unknown";
  Wrapped.displayName = `withErrorBoundary(${name})`;
  return Wrapped;
}
export {
  ErrorBoundary,
  ErrorBoundaryContext,
  useErrorBoundary,
  withErrorBoundary
};
//# sourceMappingURL=react-error-boundary.js.map
